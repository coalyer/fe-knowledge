# 浏览器渲染原理及流程

https://www.cnblogs.com/slly/p/6640761.html

我们可能都知道浏览器含有一个渲染引擎，用来渲染窗口所展示的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，用于显示 PDF 格式。但是其具体的渲染原理和流程估计也有很多人都不知道或者不清楚吧。这些天研究了一下浏览器的渲染原理，有了些心得，在这里跟大家分享一下，这里只讨论渲染引擎最主要的用途——显示应用了 CSS 之后的 html 及图片。

## 渲染引擎简介

本文所讨论的浏览器——Firefox、Chrome 和 Safari 是基于两种渲染引擎构建的，Firefox 使用 Geoko——Mozilla 自主研发的渲染引擎，Safari 和 Chrome 都使用 webkit。

## 渲染主流程

渲染引擎首先通过网络获得所请求文档的内容，通常以 8K 分块的方式完成。

### 基本流程

下面是渲染引擎在取得内容之后的基本流程：

1. 解析 html 以构建 dom 树
2. 构建 render 树
3. 布局 render 树
4. 绘制 render 树

![img](https://pic002.cnblogs.com/images/2011/265173/2011110316263715.png)

### 几个概念

这里先解释一下几个概念，方便大家理解：

1. DOM Tree：浏览器将 HTML 解析成树形的数据结构。
2. CSS Rule Tree：浏览器将 CSS**解析成树形的数据结构**。
3. Render Tree: DOM 和 CSSOM 合并后生成 Render Tree。
4. layout: 有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。
5. painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。
6. reflow（回流）：**当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow**。reflow 会从 \<html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。
7. repaint（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，**屏幕的一部分要重画，但是元素的几何尺寸没有变**。

注意：

1. display:none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以，如果**某个节点最开始是不显示的，设为 display:none 是更优的**。

2. **display:none 会触发 reflow**，而 **visibility:hidden 只会触发 repaint**，因为没有发现位置变化。（**最开始显示时，设为 visibility:hidden 是更优的**）
3. 有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫**异步 reflow** 或**增量异步 reflow**。但是在有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会**马上进行 reflow**。


### Webkit & Geoko流程区别

webkit 的主要流程

![img](https://images2018.cnblogs.com/blog/1028513/201805/1028513-20180530154313816-1498972038.png)

Geoko 的主要流程

![img](https://images2018.cnblogs.com/blog/1028513/201805/1028513-20180530154341813-2090367224.jpg)

- Gecko 里把格式化好的可视元素称做**“帧树”（Frame tree）**。每个元素就是一个帧（frame）。 webkit 则使用**”渲染树”（Render tree）**这个术语，渲染树由”渲染对象”组成。
- **webkit 里使用”layout”表示元素的布局，Gecko 则称为”reflow”**。
- Webkit 使用”Attachment”来连接 DOM 节点与可视化信息以构建渲染树。一个非语义上的小差别是 Gecko 在 HTML 与 DOM 树之间有一个附加的层 ，称作”content sink”，是创建 DOM 对象的工厂。

## 渲染流程

尽管 Webkit 与 Gecko 使用略微不同的术语，这个过程还是基本相同的，如下：

1. 浏览器会将 HTML 解析成一个 **DOM Tree**，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。

2. 将 CSS 解析成 **CSS Rule Tree** 。

3. 根据 DOM 树和 CSSOM 来构造 **Rendering Tree**。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。

4. 有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系。下一步操作称之为 **layout**，顾名思义就是计算出每个节点在屏幕中的位置。

5. 再下一步就是**绘制**，即遍历 render 树，并使用 UI 后端层绘制每个节点。

注意：_上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容_。

