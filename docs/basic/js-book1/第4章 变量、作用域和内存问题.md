# 第4章 变量、作用域和内存问题

**_本章内容_**

- 理解基本类型和引用类型的值
- 理解执行环境
- 理解垃圾收集

**_JavaScript 的变量与其他语言的变量有很大区别：_**

- JavaScript 变量**松散类型的本质**，决定了它只是在特定时间用于保存特定值的一个名字而已。

- 由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其**数据类型可以在脚本的生命周期内改变**。

- - 尽管从某种角度看，这可能是一个既有趣又强大，同时又容易出问题的特性，但 JavaScript 变量实际的复杂程度还远不止如此。

此章讲的是**变量**

## 4.1 基本类型和引用类型的值

**_1. 变量的值类型_**

ECMAScript 变量可能包含两种不同数据类型的值：

- **基本类型值**，指的是简单的数据段

- **引用类型值**，指那些可能由多个值构成的**对象**

在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。

**_2.基本类型值_**

- 第 3 章讨论了 5 种基本数据类型：Undefined、Null、Boolean、Number 和 String。
- 这 5 种基本数据类型是**按值访问**的，因为**可以操作保存在变量中的实际的值**

**_3.引用类型值_**

- 保存在内存中的**对象**。
- 与其他语言不同，**JavaScript 不允许直接访问内存中的值**，也就是说**不能直接操作对象的内存空间**。在操作对象时，实际上是在**操作对象的引用而不是实际的对象**。
- **引用类型的值**是按引用访问的。
- 在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。**ECMAScript 放弃了这一传统**。

**_4.如何定义基本类型值和引用类型值_**

定义基本类型值和引用类型值的方式是类似的：**创建一个变量**并为该变量**赋值**。

### 4.1.1 动态的属性

**_1. 动态的属性_**

当这个值保存到变量中以后，对不同类型值可以执行的操作则大相径庭：

- 对于引用类型的值，我们**可以为其添加属性和方法**，也可以改变和删除其属性和方法。

  ```js
  var person = new Object()
  person.name = "Nicholas"
  alert(person.name) //"Nicholas"
  ```

- 对于基本类型的值，我们**不能给其添加属性**，尽管这样做不会导致任何错误。

  ```js
  var name = "Nicholas"
  name.age = 27
  alert(name.age) //undefined
  ```

### 4.1.2 复制变量值

**_1. 复制变量值_**

基本类型值和引用类型值除了保存的方式不同之外（见上一节），在从一个变量向另一个变量复制时，也存在不同：

- 复制基本类型的值，会在**变量对象上创建一个新值**，然后把该值复制到为新变量分配的位置上。

  ```js
  var num1 = 5
  var num2 = num1
  ```

  <img src="/js-book1/basic_type.png" alt="basic_type" style="zoom:75%;" />

- 复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的**副本实际上是一个指针**，而这个**指针指向存储在堆中的一个对象**。

  - **复制操作结束后，两个变量实际上将引用同一个对象**。因此，**改变其中一个变量，就会影响另一个变量**

  ```js
  var obj1 = new Object()
  var obj2 = obj1
  obj1.name = "Nicholas"
  alert(obj2.name) //"Nicholas"
  ```

  <img src="/js-book1/reference_type.png" alt="reference_type" style="zoom:75%;" />

### 4.1.3 传递参数

**_1. 按值传递_**

ECMAScript 中**所有函数的参数**都是**按值传递**的。

- 也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。（**同复制**）

- - 基本类型值的传递如同基本类型变量的复制一样，
  - 引用类型值的传递，则如同引用类型变量的复制一样

- 有不少开发人员在这一点上可能会感到困惑

  - **访问变量**有按值和按引用两种方式
  - **参数**只能按值传递

**_2. 向参数传递基本类型的值_**

被传递的**值会被复制给一个局部变量**（即命名参数，或者用 ECMAScript 的概念来说，就是 arguments 对象中的一个元素），因此这个局部变量的变化**不会反映在函数的外部**。

```js
function addTen(num) {
  num += 10
  return num
}
var count = 20
var result = addTen(count)
alert(count) //20，没有变化
alert(result) //30
```

**_3. 向参数传递引用类型的值_**

被传递的**值在内存中的地址复制给一个局部变量**，因此这个局部变量的变化**会反映在函数的外部**。

```js
function setName(obj) {
  obj.name = "Nicholas"
}
var person = new Object()
setName(person)
alert(person.name) //"Nicholas"
```

- 有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是**按引用传递**的。

  - **按值传递**的含义：**复制传**，复制传进来的对象的地址，把这个复制值赋给参数引用传递的含义
  - **引用传递**的含义：**直接传**，**直接将变量本身的地址传进去，直接把传进来的对象的地址传给参数**，而**不是复制变量值**

- 为了证明对象是**按值传递**的，我们再看一看下面这个经过修改的例子：

  ```js
  function setName(obj) {
    obj.name = "Nicholas"
    obj = new Object()
    obj.name = "Greg"
  }
  var person = new Object()
  setName(person)
  alert(person.name) //"Nicholas"
  ```

  - 这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。

  - 实际上，当在函数内部重写 obj 时，这个**变量引用的就是一个局部对象**了。而这个局部对象会在函数执行完毕后立即被销毁。

**_4.局部变量_**

可以把 ECMAScript 函数的参数想象成局部变量。

### 4.1.4 检测类型

**_1. 检测基本数据类型_**

要检测一个变量是不是基本数据类型？第 3 章介绍的**typeof 操作符**是最佳的工具。

- typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具。
- 如果变量的值是一个对象或 null，则 typeof 操作符会像下面例子中所示的那样返回"object"：

**_2. 检测引用数据类型_**

在检测引用类型的值时，typeof 操作符的用处不大。想知道它是什么类型的对象。为此，ECMAScript 提供了 instanceof 操作符

语法：

```js
result = variable instanceof constructor
```

- 如果变量是给定引用类型（根据它的原型链来识别；第 6 章将介绍原型链）的实例，那么 instanceof 操作符就会返回 true。

- 如果使用 instanceof 操作符检测基本类型的值，则该操作符始终会返回 false，因为基本类型不是对象。

  ```js
  alert(person instanceof Object) // 变量person 是Object 吗？
  alert(colors instanceof Array) // 变量colors 是Array 吗？
  alert(pattern instanceof RegExp) // 变量pattern 是RegExp 吗？
  ```

**_3.兼容性_**

使用 typeof 操作符检测函数时，该操作符会返回"function"。

- 在 Safari 5 及之前版本和 Chrome 7 及之前版本中，对正则表达式应用 typeof 会返回"function"。
- 在 IE 和 Firefox 中，对正则表达式应用 typeof 会返回"object"。

## 4.2 执行环境及作用域

**_1. 执行环境_**

**执行环境**（execution context，为简单起见，有时也称为“**环境**”）是 JavaScript 中最为重要的一个概念。定义了变量或函数有权访问的其他数据，决定了它们各自的行为。

每个执行环境都有一个与之关联的**变量对象**（variable object），环境中定义的所有变量和函数都保存在这个对象中。

- 全局执行环境是最外围的一个执行环境。

  - 根据 ECMAScript 实现所在的宿主环境不同，表示执行环境的对象也不一样。
  - 全局执行环境被认为是 window 对象（第 7 章将详细讨论）
  - 因此所有全局变量和函数都是作为 window 对象的属性和方法创建的
  - 某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。

- 每个函数都有自己的执行环境。
  - 当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。
  - 在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。
  - ECMAScript 程序中的执行流正是由这个方便的机制控制着。

**_2. 作用域链_**

当代码在一个环境中执行时，会创建变量对象的一个**作用域链**（scope chain）

- 作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。

- 作用域链的前端，始终都是当前执行的代码所在环境的变量对象。
- 作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。

如果这个环境是函数，则将其**活动对象**（activation object）作为变量对象。

- 活动对象在最开始时只包含一个变量，即**arguments 对象**（这个对象在全局环境中是不存在的）。

- 全局执行环境的变量对象始终都是作用域链中的最后一个对象。

  ```js
  var color = "blue"
  function changeColor() {
    if (color === "blue") {
      color = "red"
    } else {
      color = "blue"
    }
  }
  changeColor()
  alert("Color is now " + color)
  ```

  - 函数 changeColor()的作用域链包含两个对象：它自己的变量对象（其中定义着 arguments 对象）和全局环境的变量对象。

此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用

- 这些环境之间的联系是线性、有次序的。
- 每个环境都可以**向上搜索作用域**链，以查询变量和函数名；但任何环境都**不能向下搜索作用域链**而进入另一个执行环境。

- 函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。

  ```js
  var color = "blue"
  function changeColor() {
    var anotherColor = "red"
    function swapColors() {
      var tempColor = anotherColor
      anotherColor = color
      color = tempColor
      // 这里可以访问color、anotherColor 和tempColor
    }
    // 这里可以访问color 和anotherColor，但不能访问tempColor
    swapColors()
  }
  // 这里只能访问color
  changeColor()
  ```

  - 下图形象地展示了前面这个例子的作用域链

    ![scope_chain](/js-book1/scope_chain.png)

### 4.2.1 延长作用域链

虽然执行环境的类型总共只有两种——全局和局部（函数），但还是有其他办法来延长作用域链。

**_1. 为什么可以延长作用域链？_**

是因为有些语句可以在作用域链的前端**临时增加一个变量对象**，该变量对象会在代码执行后被移除。

下列语句可延长作用域链：

- try-catch 语句的 catch 块；

- with 语句。

- - 对 with 语句来说，会将指定的对象添加到作用域链中。
  - 对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。

```js
function buildUrl() {
  var qs = "?debug=true"
  with (location) {
    var url = href + qs
  }
  return url
}
```

- with 语句接收的是 location 对象，而这个变量对象被添加到了作用域链的前端。
- with 语句内部，则定义了一个名为 url 的变量，因而 url 就成了函数执行环境的一部分，所以可以作为函数的值被返回。

### 4.2.2 没有块级作用域

**_1. JavaScript 没有块级作用域经常会导致理解上的困惑_**

- 在其他类 C 的语言中，由花括号封闭的代码块都有自己的作用域（如果用 ECMAScript 的话来讲，就是它们自己的执行环境）

if 语句：

```js
if (true) {
  var color = "blue"
}
alert(color) //"blue"
```

- 在 C、C++或 Java 中，color 会在 if 语句执行完毕后被销毁。
- 在 JavaScript 中
  - if 语句中的变量声明会**将变量添加到当前的执行环境**（在这里是全局环境）中。
  - 因而支持根据条件来定义变量。

for 语句：

```js
for (var i = 0; i < 10; i++) {
  doSomething(i)
}
alert(i) //10
```

- 由 for 语句创建的变量 i 即使在 for 循环执行结束后，也依旧会**存在于循环外部的执行环境**中。

**_2. 声明变量_**

- 使用 var 声明的变量会自动**被添加到最接近的环境**中。
- 没有使用 var 声明，该变量会自动被添加到全局环境。
- 建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。

```js
function add(num1, num2) {
  var sum = num1 + num2
  return sum
}
var result = add(10, 20) //30
alert(sum) //由于sum 不是有效的变量，因此会导致错误
```

```js
function add(num1, num2) {
  sum = num1 + num2
  return sum
}
var result = add(10, 20) //30
alert(sum) //30
```

**_3. 查询标识符过程_**

通过下面这个示例，可以理解查询标识符的过程：

```js
var color = "blue"
function getColor() {
  return color
}
alert(getColor()) //"blue"
```

- 首先，搜索 getColor()的变量对象，查找其中是否包含一个名为 color 的标识符。在没有找到的情况下，搜索继续到下一个变量对象（全局环境的变量对象），然后在那里找到了名为 color 的标识符。

  <img src="/js-book1/block_scope.png" alt="block_scope" style="zoom:75%;" />

- 在这个搜索过程中，如果存在一个局部的变量的定义，则搜索会自动停止，不再进入另一个变量对象。

  ```js
  var color = "blue"
  function getColor() {
    var color = "red"
    return color
  }
  alert(getColor()) //"red"
  ```

**_4. 如何访问全局变量_**

- 任何位于局部变量 color 的声明之后的代码，如果不使用 window.color 都无法访问全局 color 变量。

- 访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链。

## 4.3 垃圾收集

**_1. 垃圾收集机制_**

- JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。
  - 在 C 和 C++之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问题的一个根源。
  - JavaScript 所需内存的分配以及无用内存的回收完全实现了自动管理。
- 这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。
- 垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。

**_2. 变量生命周期_**

分析函数中局部变量的正常生命周期：

- 为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。
- 然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。

**_3. 变量打标记_**

上述情况很容易判断变量是否还有存在的必要；但并非所有情况下都这么容易就能得出结论。

垃圾收集器对于不再有用的变量打上标记，以备将来收回其占用的内存。通常有两

个策略：

- 标记清除
- 引用计数

### 4.3.1 标记清除

**_1. 标记清除原理_**

JavaScript 中最常用的垃圾收集方式是**标记清除**（mark-and-sweep）

- 当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。
- 可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录

**_2. 标记清除过程_**

垃圾收集器在运行的时候：

- 给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。
- 然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。
- 最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

**_3.标记清除重要性_**

到 2008 年为止，IE、Firefox、Opera、Chrome 和 Safari 的 JavaScript 实现使用的都是标记清除式的垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。

### 4.3.2 引用计数

**_1. 引用计数原理_**

另一种不太常见的垃圾收集策略叫做**引用计数**（reference counting），跟踪记录每个值被引用的次数。

当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。

**_2. 问题：循环引用_**

Netscape Navigator 3.0 是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：**循环引用**。Netscape 在 Navigator 4.0 中放弃了引用计数方式。

```js
function problem() {
  var objectA = new Object()
  var objectB = new Object()
  objectA.someOtherObject = objectB
  objectB.anotherObject = objectA
}
```

只要在 IE 中涉及 COM 对象，就会存在循环引用的问题。

- IE 中有一部分对象并不是原生 JavaScript 对象。

  例如：

  - 其 BOM 和 DOM 中的对象就是使用 C++以 COM（Component Object Model，组件对象模型）对象的形式实现的，而 COM 对象的垃圾收集机制采用的就是引用计数策略。
  - 因此，即使 IE 的 JavaScript 引擎是使用标记清除策略来实现的，但 JavaScript 访问的 COM 对象依然是基于引用计数策略的。

  ```js
  var element = document.getElementById("some_element")
  var myObject = new Object()
  myObject.element = element
  element.someObject = myObject
  ```

- IE9 把 BOM 和 DOM 对象都转换成了真正的 JavaScript 对象。这样，就避免了**两种垃圾收集算法并存导致的问题**，也消除了**常见的内存泄漏现象**。

  ```js
  myObject.element = null
  element.someObject = null
  ```

**_3._**

导致循环引用的情况不止这些，其他一些情况将在本书中陆续介绍。

### 4.3.3 性能问题

**_1. 如何提升性能_**

- 确定垃圾收集的时间间隔是一个非常重要的问题。
  - 垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。
- 让人联想到 IE 因此而声名狼藉的性能问题。IE 的垃圾收集器机制：
  - 略

**_2. 如何触发收集过程_**

事实上，在有的浏览器中可以触发垃圾收集过程，但我们不建议读者这样做。

- 在 IE 中，调用 window.CollectGarbage()方法会立即执行垃圾收集。
- 在 Opera 7 及更高版本中，调用 window.opera.collect()也会启动垃圾收集例程。

### 4.3.4 管理内存

**_1. 为什么要内存管理_**

- 使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。
- 分配给 Web 浏览器的可用内存数量通常要比分配给桌面应用程序的少。
  - 出于安全方面的考虑，防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。
  - 内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。
- 确保占用最少的内存可以让页面获得更好的性能。

**_2. 如何管理----解除引用_**

优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。

- 一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做**解除引用**（dereferencing）。

  - 这一做法适用于大多数全局变量和全局对象的属性。
  - 局部变量会在它们离开执行环境时**自动被解除**引用

  ```js
  function createPerson(name) {
    var localPerson = new Object()
    localPerson.name = name
    return localPerson
  }
  var globalPerson = createPerson("Nicholas")
  // 手工解除globalPerson 的引用
  globalPerson = null
  ```

- 不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

## 4.4 小结

**_1. JavaScript 变量可以用来保存两种类型的值：_**

- 基本类型值
- 引用类型值

**_2. 基本类型的值源自以下 5 种基本数据类型：_**

- Undefined、
- Null、
- Boolean、
- Number、
- String。

**_3. 基本类型值和引用类型值具有以下特点：_**

- 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
- 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
- 引用类型的值是对象，保存在堆内存中；
- 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
- 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象
- 确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用 instanceof 操作符。

**_4. 关于执行环境的几点总结：_**

所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。

- 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；
- 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
- 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；
- 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；
- 变量的执行环境有助于确定应该何时释放内存。

**_5. 对 JavaScript 的垃圾收集例程作如下总结：_**

JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。

- 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。
- “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。
- 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript 引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种算法仍然可能会导致问题。
- 当代码中存在循环引用现象时，“引用计数”算法就会导致问题。
- 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。
